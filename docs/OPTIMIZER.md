# 优化器模块 (`scripts/hardware_optimizer.py`)

## 详细模块文档

*   [核心思想与工作流程](./CORE_IDEAS.md)
*   [数据模块 (`compass/data`)](./DATA_MODULE.md)
*   [模型模块 (`compass/training/model.py`)](./MODEL_MODULE.md)
*   [引擎模块 (`compass/engine`)](./ENGINE_MODULE.md)
*   [**优化器模块 (本文档)**](./OPTIMIZER.md)

---

## 1. 核心解决的矛盾

想象一个场景：你刚拿到一台配备了全新 GPU（比如 RTX 4090）的服务器，准备开始一个新模型的训练。你面临的第一个，也是最基本的问题是：**“对于这块硬件，最佳的训练配置是什么？”**

这个问题背后，是一个棘手的“不可能三角”问题，你需要在三个相互冲突的目标之间做出艰难的权衡：

1.  **模型性能 (Quality)**：我应该把[模型](./MODEL_MODULE.md)的层数（`num_layers`）和隐藏维度（`hidden_channels`）设多大，才能达到最高的预测精度？
2.  **训练速度 (Time)**：我应该把批次大小（`batch_size`）设多大，才能让每个 epoch 的训练时间最短，从而最快地迭代？
3.  **硬件限制 (Memory)**：我如何将上述配置塞进有限的 GPU 显存里，而不会在训练开始几分钟后就遭遇灾难性的 `CUDA out of memory` 错误？

手动寻找这个最佳平衡点，是一个极其枯燥、乏味且充满挫败感的过程，你可能需要花一整天甚至更长的时间，像没头苍蝇一样不断地试错和调整参数。

本[优化器模块 (`scripts/hardware_optimizer.py`)](./OPTIMIZER.md)的核心使命，就是将这个过程完全自动化。它通过承认“最佳配置”完全取决于你当前所处的开发阶段，从而智能地解决了这个“不可能三角”的矛盾。

## 2. 工作流程与核心思想

本模块的核心是一个独立的脚本 `scripts/hardware_optimizer.py`。其智能根植于一个分层的开发哲学：为开发工作流的每个特定阶段提供量身定制的权衡策略。

优化器的工作流被定义为三个核心阶段，每个阶段都有一个独特的优化目标：

1.  **`prototyping` (原型设计阶段)**
    *   **核心思想**: **时间至上 (Time is the ruler)**。此阶段的目标是快速试错。配置必须足够快，以便开发人员能够迅速测试想法。
    *   **工作策略**: 优化器会以一个软性的时间目标（例如~20分钟）为预算，在其专用的**小型模型搜索空间**中，寻找能在这个时间预算内实现**最高吞吐量（最大批次大小）** 的配置。这确保了最快的迭代速度。

2.  **`validation` (验证阶段)**
    *   **核心思想**: **平衡是关键 (Balance is the key)**。此阶段是连接“有前途的原型”和“全尺寸生产模型”的关键桥梁。它必须足够接近生产质量以给出有意义的结果，但又不能太慢而拖累开发流程。
    *   **工作策略**: 优化器以一个中等的时间目标（例如~90分钟）为预算，在其专用的**大型模型搜索空间**中，寻找具有**最高吞吐量**的配置，以实现速度和质量的完美平衡。

3.  **`production` (生产阶段)**
    *   **核心思想**: **质量是最终目标 (Quality is the ultimate goal)**。在这个阶段，时间不再是主要限制。目标是构建硬件和数据能支持的、最好的模型。
    *   **工作策略**: 它采用一个两阶段的优化过程：首先，它会找到在硬件和数据限制下，质量最高（最大、最复杂）的[模型](./MODEL_MODULE.md)；然后，它会为这个最佳模型找到硬件所能承受的极限批次大小，以榨干所有性能。

### 从工具到产品的演进

为了将这一哲学思想转化为一个健壮、智能的工程产品，优化器经历了一系列重要的演进：

*   **配置即代码**: 所有的关键参数（如模型搜索空间、VRAM 缩放因子、时间预算）都被提取到专门的 `optimizer_config.py` 文件中，实现了逻辑和配置的分离。
*   **智能算法**: 摒弃了原始的网格搜索，为 `prototyping` 和 `validation` 模式引入了**贝叶斯优化**。优化器能从每次测试中学习，智能地选择下一个最有希望的候选配置，从而用更少的步骤找到更好的配置。
*   **专业的日志系统**: 所有 `print` 语句都被替换为专业的 `logging` 系统，将带有时间戳、分级别的日志同时输出到控制台和日志文件 (`hardware_optimizer.log`)，极大地提升了可追溯性和调试效率。

## 3. 常见问题与解决方案 (FAQ)

- **问：我该如何使用这个优化器？**
  - **答：** 直接在命令行中运行 `python scripts/hardware_optimizer.py [mode]`。其中 `[mode]` 可以是 `prototyping`、`validation` 或 `production` 之一。脚本会为你的硬件找到当前阶段的最佳配置，并清晰地打印在日志中。然后你可以将这些配置填入主 `config.py` 文件。

- **问：`prototyping` 模式找到的配置似乎不是最强的模型？**
  - **答：** 是的，这是设计使然。`prototyping` 模式的首要目标是“快”，它会优先选择能在20分钟内完成测试的、速度最快的配置，而不是性能最强的配置，以保证你的迭代效率。

- **问：如何为我的项目定制优化器的搜索空间或时间预算？**
  - **答：** 打开 `scripts/optimizer_config.py` 文件。你可以在这里修改每个模式的模型搜索空间（`SMALL_MODEL_SPACE`, `LARGE_MODEL_SPACE`）、时间预算（`PROTOTYPING_TIME_BUDGET_MINS`）以及用于测试的 PDB 文件等所有关键参数。

- **问：优化器在寻找最大批次大小时报告 `CUDA out of memory`，这正常吗？**
  - **答：** 完全正常。优化器的核心功能之一就是通过“试错”来探测硬件的显存极限。它会从一个较大的批次大小开始，如果触发 OOM 错误，它会自动缩小批次大小并重试，直到找到不会导致 OOM 的最大值。最终成功运行的配置就是安全的。
