# 模型模块 (`compass/training/model.py`)

## 详细模块文档

*   [核心思想与工作流程](./CORE_IDEAS.md)
*   [数据模块 (`compass/data`)](./DATA_MODULE.md)
*   [**模型模块 (本文档)**](./MODEL_MODULE.md)
*   [引擎模块 (`compass/engine`)](./ENGINE_MODULE.md)
*   [优化器模块 (`scripts/hardware_optimizer.py`)](./OPTIMIZER.md)

---

## 1. 核心解决的矛盾

想象一个场景：作为一名AI药物发现研究员，你的[数据模块](./DATA_MODULE.md)已经能高效地将原始PDB文件处理成结构化的图数据。现在，你面临一个关键的战略选择：

**是自己从零开始，耗费数月时间设计、实现和调试一个全新的图神经网络模型？还是站在巨人的肩膀上，直接采用领域内公认的、最先进的（SOTA）预置模型？**

本项目选择后者，以最大化研究效率。但这个选择带来了新的矛盾：**“通用SOTA模型”与“本项目特定数据”之间的适配矛盾。**

具体来说：
1.  **输入格式不匹配**：我们选择了强大的 `ViSNet` 模型，但它是一个通用模型，其文档要求输入的是**原子序数**（一个整数，如 `6` 代表碳）。而我们的[数据模块 (`compass/data`)](./DATA_MODULE.md)为了灵活性和可扩展性，输出的是 **one-hot 编码**的原子特征（一个向量，如 `[1, 0, 0, ...]` 代表碳）。
2.  **封装与隔离**：我们不希望在核心的[引擎模块 (`compass/engine`)](./ENGINE_MODULE.md)中混入大量“数据格式转换”的胶水代码。训练引擎应该只关心“接收数据、调用模型、反向传播”，保持其通用性。

`ViSNetPDB` 类的存在，就是为了充当一个**适配器 (Adapter)**，在数据和模型之间建立一座桥梁。它优雅地封装了所有转换逻辑，让我们能用最小的代价，将最先进的模型无缝集成到我们的工作流中。

## 2. 工作流程与核心思想

本模块的核心思想是 **“封装与转换”**。

### `ViSNetPDB` 类 - 适配器模式的实践

`ViSNetPDB` 本身不是一个全新的图神经网络，它是一个 `torch.nn.Module` 封装。其内部“包裹”了一个真正的 `ViSNet` 实例。它的职责非常专一：

1.  **接收项目数据**: `forward` 方法接收来自[数据模块](./DATA_MODULE.md)加载器、符合我们项目特定格式的 `Data` 对象。
2.  **特征转换**: 这是适配器的核心工作。它执行一个关键的转换，将 `data.x`（一个 one-hot 特征矩阵）转换为 `ViSNet` 能理解的原子序数向量 `z`。
    -   **`z_idx = data.x.argmax(dim=-1)`**: 对于每个原子，找到其 one-hot 向量中值为 1 的位置索引。这个索引代表了它在我们的元素列表 `['C', 'O', 'N', ...]` 中的位置。
    -   **`z = self.index_to_z[z_idx]`**: 使用预定义的 `INDEX_TO_Z` 映射张量，将上述索引直接转换为对应的原子序数（例如，索引 0 -> 原子序数 6 (碳)，索引 1 -> 原子序数 8 (氧)）。
3.  **调用核心模型**: 将转换后的原子序数 `z`、原子坐标 `data.pos` 和批次信息 `data.batch` 传递给内部的 `self.visnet` 实例。
4.  **返回结果**: 将 `ViSNet` 的输出（预测的结合亲和力）原样返回给[引擎模块 (`compass/engine`)](./ENGINE_MODULE.md)。

### 为什么选择 `ViSNet`？

`ViSNet` (Vector-Scalar Interactive Network) 是一个为三维分子图设计的**等变图神经网络 (Equivariant GNN)**。选择它的核心优势在于：

-   **旋转等变性**: 如果你将输入的分子在三维空间中旋转，模型的内部向量表示也会以相同的方式旋转，但最终的标量预测值（如能量、亲和力）保持不变。这完美符合“分子的性质与其在空间中的朝向无关”这一物理直觉，使得模型能更高效地学习分子结构与性质的内在关系。

## 3. 常见问题与解决方案 (FAQ)

- **问：我想调整模型的超参数，比如层数或隐藏维度，在哪里修改？**
  - **答：** 在 `compass/training/model.py` 文件的 `ViSNetPDB` 的 `__init__` 方法中，你可以看到 `ViSNet` 的所有超参数，如 `hidden_channels`, `num_layers` 等。最佳实践是将这些参数移到主配置文件 `config.py` 中进行管理，方便通过[优化器模块](./OPTIMIZER.md)进行自动搜索。

- **问：我想换一个不同的模型，比如 `SchNet`，该如何操作？**
  - **答：** 这是本模块适配器模式的最大优势。你只需：
    1.  新建一个类似 `SchNetPDB` 的封装类。
    2.  在其 `forward` 方法中，同样进行从 `data.x` 到原子序数 `z` 的转换。
    3.  调用 `SchNet` 模型并返回结果。
    4.  在[引擎模块](./ENGINE_MODULE.md)的初始化部分，将实例化的模型从 `ViSNetPDB` 更换为 `SchNetPDB` 即可，其他代码（数据、引擎）几乎无需改动。

- **问：`INDEX_TO_Z` 这个张量是什么？我可以修改它吗？**
  - **答：** 这个张量是 one-hot 索引到原子序数的“密码本”。它的顺序**必须**与 `compass/data/features.py` 中定义的元素列表 `ELEMENTS` 严格对应。如果你想增加或改变支持的元素，你需要同时修改 `features.py` 中的 `ELEMENTS` 列表和 `model.py` 中的 `INDEX_TO_Z` 张量，并确保两者顺序一致。
