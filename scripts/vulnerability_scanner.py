"""
Vulnerability scanner for security and performance issues.
"""

import asyncio
import json
import logging
import time
import requests
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any
import sys

# Add project root to path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from config.debug_config import (
    BACKEND_URL,
    REGISTRY_URL,
    SECURITY_TESTS,
    PERFORMANCE_TESTS,
    API_ENDPOINTS,
)

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)


class VulnerabilityScanner:
    """Scanner for security vulnerabilities and performance issues."""

    def __init__(self):
        self.vulnerabilities: List[Dict[str, Any]] = []
        self.performance_issues: List[Dict[str, Any]] = []

    def scan_cors_configuration(self) -> List[Dict[str, Any]]:
        """Scan CORS configuration for vulnerabilities."""
        logger.info("Scanning CORS configuration")
        vulnerabilities = []

        try:
            # Test CORS with different origins
            for origin in SECURITY_TESTS["cors"]["test_origins"]:
                headers = {"Origin": origin, "Access-Control-Request-Method": "GET"}
                response = requests.options(
                    f"{BACKEND_URL}/api/v1/training/tasks", headers=headers, timeout=10
                )

                # Check if CORS allows all origins
                cors_headers = response.headers.get("Access-Control-Allow-Origin", "")
                if cors_headers == "*" or origin in cors_headers:
                    vulnerability = {
                        "type": "security",
                        "severity": "high",
                        "category": "cors",
                        "title": "CORS allows all origins",
                        "description": f"CORS configuration allows requests from {origin}",
                        "location": "compass/service/server.py",
                        "recommendation": "Restrict CORS to specific trusted origins",
                        "timestamp": datetime.now().isoformat(),
                    }
                    vulnerabilities.append(vulnerability)
                    logger.warning(f"CORS vulnerability found: {origin}")

        except Exception as e:
            logger.error(f"Error scanning CORS: {e}")

        return vulnerabilities

    def scan_authentication(self) -> List[Dict[str, Any]]:
        """Scan for missing authentication."""
        logger.info("Scanning authentication")
        vulnerabilities = []

        try:
            # Test endpoints without authentication
            for endpoint_path in SECURITY_TESTS["authentication"]["test_endpoints"]:
                url = f"{BACKEND_URL}{endpoint_path}"
                response = requests.get(url, timeout=10)

                # If endpoint is accessible without authentication, it's a vulnerability
                if response.status_code != 401 and response.status_code != 403:
                    vulnerability = {
                        "type": "security",
                        "severity": "high",
                        "category": "authentication",
                        "title": "Missing authentication",
                        "description": f"Endpoint {endpoint_path} is accessible without authentication",
                        "location": f"compass/service/routes/{endpoint_path.split('/')[3]}.py",
                        "recommendation": "Implement API key authentication or JWT tokens",
                        "timestamp": datetime.now().isoformat(),
                    }
                    vulnerabilities.append(vulnerability)
                    logger.warning(f"Authentication vulnerability found: {endpoint_path}")

        except Exception as e:
            logger.error(f"Error scanning authentication: {e}")

        return vulnerabilities

    def scan_file_upload_security(self) -> List[Dict[str, Any]]:
        """Scan file upload security."""
        logger.info("Scanning file upload security")
        vulnerabilities = []

        try:
            # Check if file upload endpoint exists
            upload_endpoint = "/api/v1/data/upload"

            # Test with invalid file type (should be rejected)
            try:
                invalid_file = {"file": ("malicious.exe", b"malicious content")}
                response = requests.post(
                    f"{BACKEND_URL}{upload_endpoint}", files=invalid_file, timeout=10
                )

                # Check response - if it accepts .exe files, that's a vulnerability
                if response.status_code == 201 or response.status_code == 200:
                    vulnerability = {
                        "type": "security",
                        "severity": "high",
                        "category": "file_upload",
                        "title": "File upload accepts invalid file types",
                        "description": f"File upload endpoint accepted .exe file. Status: {response.status_code}",
                        "location": "compass/service/routes/data.py",
                        "recommendation": "Validate file extensions and reject executable files",
                        "timestamp": datetime.now().isoformat(),
                    }
                    vulnerabilities.append(vulnerability)
                elif response.status_code == 400:
                    # Good - it rejected the file
                    logger.info("File upload correctly rejected invalid file type")
            except Exception as e:
                logger.warning(f"Could not test file upload with invalid file: {e}")

            # Note: File size validation is already implemented in data.py
            # But we should verify it works correctly
            # Check the code for file size validation
            vulnerability = {
                "type": "security",
                "severity": "info",
                "category": "file_upload",
                "title": "File upload security verification",
                "description": "File upload endpoint has file size and type validation. Verify it works correctly in production.",
                "location": "compass/service/routes/data.py",
                "recommendation": "Test with actual large files and malicious files in production",
                "timestamp": datetime.now().isoformat(),
            }
            vulnerabilities.append(vulnerability)

        except Exception as e:
            logger.error(f"Error scanning file upload: {e}")

        return vulnerabilities

    def scan_input_validation(self) -> List[Dict[str, Any]]:
        """Scan for input validation issues."""
        logger.info("Scanning input validation")
        vulnerabilities = []

        try:
            # Test SQL injection (if database is used)
            sql_injection_payloads = SECURITY_TESTS["input_validation"]["sql_injection"]
            for payload in sql_injection_payloads:
                # Test on a GET endpoint with query parameters
                url = f"{BACKEND_URL}/api/v1/training/tasks?task_id={payload}"
                response = requests.get(url, timeout=10)

                # Check if error message reveals database structure
                if "sql" in response.text.lower() or "database" in response.text.lower():
                    vulnerability = {
                        "type": "security",
                        "severity": "high",
                        "category": "sql_injection",
                        "title": "Potential SQL injection vulnerability",
                        "description": f"Endpoint may be vulnerable to SQL injection: {payload}",
                        "location": "compass/service/routes/training.py",
                        "recommendation": "Use parameterized queries and input validation",
                        "timestamp": datetime.now().isoformat(),
                    }
                    vulnerabilities.append(vulnerability)

            # Test XSS (if applicable)
            xss_payloads = SECURITY_TESTS["input_validation"]["xss"]
            for payload in xss_payloads:
                # Test on a POST endpoint
                url = f"{BACKEND_URL}/api/v1/training/tasks"
                data = {"description": payload}
                response = requests.post(url, json=data, timeout=10)

                # Check if payload is reflected in response
                if payload in response.text:
                    vulnerability = {
                        "type": "security",
                        "severity": "medium",
                        "category": "xss",
                        "title": "Potential XSS vulnerability",
                        "description": f"Endpoint may be vulnerable to XSS: {payload}",
                        "location": "compass/service/routes/training.py",
                        "recommendation": "Sanitize user input and use Content-Security-Policy",
                        "timestamp": datetime.now().isoformat(),
                    }
                    vulnerabilities.append(vulnerability)

        except Exception as e:
            logger.error(f"Error scanning input validation: {e}")

        return vulnerabilities

    def scan_rate_limiting(self) -> List[Dict[str, Any]]:
        """Scan rate limiting implementation."""
        logger.info("Scanning rate limiting")
        vulnerabilities = []

        try:
            # Test rate limiting by sending multiple requests
            endpoint = "/api/v1/training/tasks"
            requests_per_minute = SECURITY_TESTS["rate_limiting"]["requests_per_minute"]

            rate_limit_hit = False
            for i in range(requests_per_minute):
                response = requests.get(f"{BACKEND_URL}{endpoint}", timeout=10)
                if response.status_code == 429:
                    rate_limit_hit = True
                    break
                time.sleep(0.1)

            if not rate_limit_hit:
                vulnerability = {
                    "type": "security",
                    "severity": "medium",
                    "category": "rate_limiting",
                    "title": "Rate limiting may be insufficient",
                    "description": f"Endpoint did not trigger rate limit after {requests_per_minute} requests",
                    "location": "compass/service/middleware/rate_limit.py",
                    "recommendation": "Review and adjust rate limiting configuration",
                    "timestamp": datetime.now().isoformat(),
                }
                vulnerabilities.append(vulnerability)

        except Exception as e:
            logger.error(f"Error scanning rate limiting: {e}")

        return vulnerabilities

    def scan_performance_issues(self) -> List[Dict[str, Any]]:
        """Scan for performance issues."""
        logger.info("Scanning performance issues")
        issues = []

        try:
            # Test API endpoint response times
            slow_threshold = PERFORMANCE_TESTS["slow_request_threshold"]

            for category, endpoints in API_ENDPOINTS.items():
                for endpoint in endpoints[:5]:  # Test first 5 endpoints per category
                    path = endpoint["path"]
                    method = endpoint["method"]

                    # Replace path parameters
                    if "{task_id}" in path:
                        path = path.replace("{task_id}", "test-task-id")
                    if "{dataset_id}" in path:
                        path = path.replace("{dataset_id}", "test-dataset-id")
                    if "{model_id}" in path:
                        path = path.replace("{model_id}", "test-model-id")

                    url = f"{BACKEND_URL}{path}"

                    start_time = time.time()
                    try:
                        if method == "GET":
                            requests.get(url, timeout=10)
                        elif method == "POST":
                            requests.post(url, json={}, timeout=10)
                        else:
                            continue

                        elapsed_time = time.time() - start_time

                        if elapsed_time > slow_threshold:
                            issue = {
                                "type": "performance",
                                "severity": "medium",
                                "category": "slow_request",
                                "title": "Slow API endpoint",
                                "description": f"Endpoint {method} {path} took {elapsed_time:.2f}s to respond",
                                "location": f"compass/service/routes/{category}.py",
                                "recommendation": "Optimize endpoint performance",
                                "response_time": elapsed_time,
                                "threshold": slow_threshold,
                                "timestamp": datetime.now().isoformat(),
                            }
                            issues.append(issue)
                            logger.warning(f"Slow endpoint: {method} {path} ({elapsed_time:.2f}s)")

                    except Exception as e:
                        logger.error(f"Error testing endpoint {path}: {e}")

        except Exception as e:
            logger.error(f"Error scanning performance: {e}")

        return issues

    def scan_all(self) -> Dict[str, Any]:
        """Run all security and performance scans."""
        logger.info("Starting vulnerability scan")

        all_vulnerabilities = []
        all_performance_issues = []

        # Security scans
        if SECURITY_TESTS["cors"]["enabled"]:
            all_vulnerabilities.extend(self.scan_cors_configuration())

        if SECURITY_TESTS["authentication"]["enabled"]:
            all_vulnerabilities.extend(self.scan_authentication())

        if SECURITY_TESTS["file_upload"]["enabled"]:
            all_vulnerabilities.extend(self.scan_file_upload_security())

        if SECURITY_TESTS["input_validation"]["enabled"]:
            all_vulnerabilities.extend(self.scan_input_validation())

        if SECURITY_TESTS["rate_limiting"]["enabled"]:
            all_vulnerabilities.extend(self.scan_rate_limiting())

        # Performance scans
        all_performance_issues.extend(self.scan_performance_issues())

        self.vulnerabilities = all_vulnerabilities
        self.performance_issues = all_performance_issues

        return {
            "vulnerabilities": all_vulnerabilities,
            "performance_issues": all_performance_issues,
            "timestamp": datetime.now().isoformat(),
        }


def main():
    """Main function."""
    scanner = VulnerabilityScanner()

    try:
        # Run all scans
        results = scanner.scan_all()

        # Save results
        results_path = "reports/vulnerability_scan_results.json"
        Path(results_path).parent.mkdir(parents=True, exist_ok=True)
        with open(results_path, "w", encoding="utf-8") as f:
            json.dump(results, f, indent=2, ensure_ascii=False)

        logger.info(f"Vulnerability scan results saved to {results_path}")
        logger.info(f"Total vulnerabilities: {len(results['vulnerabilities'])}")
        logger.info(f"Total performance issues: {len(results['performance_issues'])}")

    except Exception as e:
        logger.error(f"Error in main: {e}", exc_info=True)


if __name__ == "__main__":
    main()
